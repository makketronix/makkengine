package com.makketronix.makkengine.makkobjects;

import android.util.Log;


// Basic physics parameters with default implementation
public class PhysicsObject {
	
	private final String TAG = "ObjParam";
	private boolean isPinned = false;		// don't move
	double mass;
	double[] x	 	= {0.0, 0.0, 0.0};
	double[] a 		= {0.0, 0.0, 0.0};
	double[] v 		= {0.0, 0.0, 0.0};
	double[] f 		= {0.0, 0.0, 0.0};		// Force from rest of env
	double[] fGen 	= {0.0, 0.0, 0.0};		// Own force
	
	public PhysicsObject(double[] xInit, double[] vInit, double[] aInit, double[] fGenInit, double mass){
		if(xInit.length != 3 || vInit.length != 3 || aInit.length != 3 || fGenInit.length != 3){
			Log.e(TAG, "Incorrect initial values.");
			for(int i = 0; i < 3; i++){
				x[i] = 0;
				a[i] = 0;
				v[i] = 0;
				fGen[i] = 0;
				this.mass = Math.max(mass, 0.0);				
			}
		}
		else{
			for(int i = 0; i < 3; i++){
				x[i] = xInit[i];
				a[i] = aInit[i];
				v[i] = vInit[i];
				f[i] = fGenInit[i];
				this.mass = Math.max(mass, 0.0);
			}
		}
	}
	
	/** 
	 * Gets magnitude of acceleration vector
	 * @return Magnitude of acceleration vector
	 */
	public double getMagA(){
		return magnitude(a);
	}
	
	/**
	 * Gets magnitude of velocity vector
	 * @return Magnitude of velocity vector
	 */
	public double getMagV(){
		return magnitude(v);
	}
	
	/**
	 * Gets magnitude of position vector
	 * @return Magnitude of position
	 */
	public double getMagX(){
		return magnitude(x);
	}
	
	private double magnitude(double[] vec){
		//TODO check to make sure 3D
		return Math.sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	}
	
	/**
	 * Force from rest of environment.
	 * @param force
	 */
	public void setForce(double[] force){
		if(force.length != 3){
			Log.e(TAG, "Invalid dimension Passed");
			return;
		}
		f[0] 	= force[0];
		f[1] 	= force[1];
		f[2] 	= force[2];
	}
	
	/**
	 * Force generated by object.
	 * @param force
	 */
	public void setForceGen(double[] force){
		if(force.length != 3){
			Log.e(TAG, "Invalid dimension Passed");
			return;
		}
		fGen[0] 	= force[0];
		fGen[1] 	= force[1];
		fGen[2] 	= force[2];
	}
	
	/**
	 * Forward Euler integration if not pinned.
	 * Note: This does not update velocity.
	 *       You may need to update velocity first.
	 */
	public void updatePosition(double dt){
		if(isPinned) return;
		
		for(int i = 0; i < 3; i++){
			x[i] += v[i]*dt;
		}
	}
	
	/**
	 * Forward Euler integration.
	 */
	public void updateVelocity(double dt){
		if(isPinned) return;
		for(int i = 0; i < 3; i++){
			v[i] += a[i]*dt;
		}
	}
	
	/**
	 * Update acceleration: (ForceEnv + localForce = m*a)
	 */
	public void updateAcceleration(){
		if(isPinned) return;
		
		if(mass < 0.00001) return;
		
		a[0] = (f[0] + fGen[0])/mass;
		a[1] = (f[1] + fGen[1])/mass;
		a[2] = (f[2] + fGen[2])/mass;
		
	}
	
	/** Update the acceleration of the object
	 *  This will be useless unless updateAcceleration() is overridden to do nothing
	 *  */
	public void setAcceleration(double[] a){
		if(a.length != 3){
			Log.e(TAG, "Incorrect acceleration dimension in setAcceleration");
			return;
		}
		this.a[0] = a[0];
		this.a[1] = a[1];
		this.a[1] = a[2];
	}
	
	@Override
	public String toString(){
		return TAG;
	}

	/** 
	 * This will be called after physics paramters are called.
	 * Override this function to do crazy things in your program.
	 * For example: If |V| > 20, reduce fGEN (simulate drag).
	 * By default, it does nothing.
	 * @param dt
	 */
	public void applyCrazyLogic(float dt) {
		// TODO Auto-generated method stub
		
	}
}
